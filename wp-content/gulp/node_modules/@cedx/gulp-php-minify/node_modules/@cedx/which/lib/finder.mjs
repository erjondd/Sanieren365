import { promises } from 'fs';
import { delimiter, extname, join, resolve } from 'path';
export class Finder {
    constructor(options = {}) {
        this[Symbol.toStringTag] = 'Finder';
        let { extensions = '', path = '', pathSeparator = '' } = options;
        this.pathSeparator = pathSeparator.length ? pathSeparator : (Finder.isWindows ? ';' : delimiter);
        if (!Array.isArray(path))
            path = path.split(this.pathSeparator).filter(item => item.length > 0);
        if (!path.length) {
            const pathEnv = 'PATH' in process.env ? process.env.PATH : '';
            if (pathEnv.length)
                path = pathEnv.split(this.pathSeparator);
        }
        if (!Array.isArray(extensions))
            extensions = extensions.split(this.pathSeparator).filter(item => item.length > 0);
        if (!extensions.length && Finder.isWindows) {
            const pathExt = 'PATHEXT' in process.env ? process.env.PATHEXT : '';
            extensions = pathExt.length ? pathExt.split(this.pathSeparator) : ['.exe', '.cmd', '.bat', '.com'];
        }
        this.extensions = extensions.map(extension => extension.toLowerCase());
        this.path = path.map(directory => directory.replace(/^"+|"+$/g, ''));
    }
    static get isWindows() {
        if (process.platform == 'win32')
            return true;
        return process.env.OSTYPE == 'cygwin' || process.env.OSTYPE == 'msys';
    }
    async *find(command) {
        for (const directory of this.path)
            yield* this._findExecutables(directory, command);
    }
    async isExecutable(file) {
        try {
            const fileStats = await promises.stat(file);
            if (!fileStats.isFile())
                return false;
            return Finder.isWindows ? this._checkFileExtension(file) : this._checkFilePermissions(fileStats);
        }
        catch {
            return false;
        }
    }
    toString() {
        const values = [];
        if (this.path.length)
            values.push(`path: "${this.path.join(this.pathSeparator)}"`);
        if (this.extensions.length)
            values.push(`extensions: "${this.extensions.join(this.pathSeparator)}"`);
        return `${this[Symbol.toStringTag]}(${values.join(', ')})`;
    }
    _checkFileExtension(file) {
        return this.extensions.includes(extname(file).toLowerCase()) || this.extensions.includes(file.toLowerCase());
    }
    _checkFilePermissions(fileStats) {
        const perms = fileStats.mode;
        if (perms & 0o001)
            return true;
        const gid = process.getgid ? process.getgid() : -1;
        if (perms & 0o010)
            return gid == fileStats.gid;
        const uid = process.getuid ? process.getuid() : -1;
        if (perms & 0o100)
            return uid == fileStats.uid;
        return perms & (0o100 | 0o010) ? uid == 0 : false;
    }
    async *_findExecutables(directory, command) {
        for (const extension of [''].concat(this.extensions)) {
            const resolvedPath = resolve(join(directory, command) + extension.toLowerCase());
            if (await this.isExecutable(resolvedPath))
                yield resolvedPath;
        }
    }
}
export class FinderError extends Error {
    constructor(command, finder, message = '') {
        super(message);
        this.command = command;
        this.finder = finder;
        this.name = 'FinderError';
    }
    toString() {
        const values = [`"${this.command}"`];
        if (this.finder.path.length)
            values.push(`finder: "${this.finder.path.join(this.finder.pathSeparator)}"`);
        if (this.message.length)
            values.push(`message: "${this.message}"`);
        return `${this.name}(${values.join(', ')})`;
    }
}
//# sourceMappingURL=finder.js.map